/**
 * Core API used by Backstage backend apps.
 *
 * @packageDocumentation
 */

/// <reference types="node" />

import { BackendFeature } from '@backstage/backend-plugin-api';
import { CacheClient } from '@backstage/backend-common';
import { Config } from '@backstage/config';
import { ConfigService } from '@backstage/backend-plugin-api';
import { CorsOptions } from 'cors';
import { ErrorRequestHandler } from 'express';
import { Express as Express_2 } from 'express';
import { Format } from 'logform';
import { Handler } from 'express';
import { HelmetOptions } from 'helmet';
import * as http from 'http';
import { HttpRouterService } from '@backstage/backend-plugin-api';
import { IdentityService } from '@backstage/backend-plugin-api';
import { JsonObject } from '@backstage/types';
import { LifecycleService } from '@backstage/backend-plugin-api';
import { LoadConfigOptionsRemote } from '@backstage/config-loader';
import { LoggerService } from '@backstage/backend-plugin-api';
import { PermissionsService } from '@backstage/backend-plugin-api';
import { PluginDatabaseManager } from '@backstage/backend-common';
import { PluginEndpointDiscovery } from '@backstage/backend-common';
import { RequestHandler } from 'express';
import { RequestListener } from 'http';
import { RootHttpRouterService } from '@backstage/backend-plugin-api';
import { RootLifecycleService } from '@backstage/backend-plugin-api';
import { RootLoggerService } from '@backstage/backend-plugin-api';
import { SchedulerService } from '@backstage/backend-plugin-api';
import { ServiceFactory } from '@backstage/backend-plugin-api';
import { ServiceFactoryOrFunction } from '@backstage/backend-plugin-api';
import { TokenManagerService } from '@backstage/backend-plugin-api';
import { transport } from 'winston';
import { UrlReader } from '@backstage/backend-common';

/**
 * @public
 */
export declare interface Backend {
    add(feature: BackendFeature): void;
    start(): Promise<void>;
    stop(): Promise<void>;
}

/** @public */
export declare const cacheServiceFactory: () => ServiceFactory<CacheClient, "plugin">;

/** @public */
export declare interface ConfigFactoryOptions {
    /**
     * Process arguments to use instead of the default `process.argv()`.
     */
    argv?: string[];
    /**
     * Enables and sets options for remote configuration loading.
     */
    remote?: LoadConfigOptionsRemote;
}

/** @public */
export declare const configServiceFactory: (options?: ConfigFactoryOptions | undefined) => ServiceFactory<ConfigService, "root">;

/** @public */
export declare function createConfigSecretEnumerator(options: {
    logger: LoggerService;
    dir?: string;
}): Promise<(config: Config) => Iterable<string>>;

/**
 * Creates a Node.js HTTP or HTTPS server instance.
 *
 * @public
 */
export declare function createHttpServer(listener: RequestListener, options: HttpServerOptions, deps: {
    logger: LoggerService;
}): Promise<ExtendedHttpServer>;

/**
 * @public
 */
export declare function createSpecializedBackend(options: CreateSpecializedBackendOptions): Backend;

/**
 * @public
 */
export declare interface CreateSpecializedBackendOptions {
    services: ServiceFactoryOrFunction[];
}

/** @public */
export declare const databaseServiceFactory: () => ServiceFactory<PluginDatabaseManager, "plugin">;

/**
 * The default implementation of the {@link @backstage/backend-plugin-api#RootHttpRouterService} interface for
 * {@link @backstage/backend-plugin-api#coreServices.rootHttpRouter}.
 *
 * @public
 */
export declare class DefaultRootHttpRouter implements RootHttpRouterService {
    #private;
    static create(options?: DefaultRootHttpRouterOptions): DefaultRootHttpRouter;
    private constructor();
    use(path: string, handler: Handler): void;
    handler(): Handler;
}

/**
 * Options for the {@link DefaultRootHttpRouter} class.
 *
 * @public
 */
export declare interface DefaultRootHttpRouterOptions {
    /**
     * The path to forward all unmatched requests to. Defaults to '/api/app' if
     * not given. Disables index path behavior if false is given.
     */
    indexPath?: string | false;
}

/** @public */
export declare const discoveryServiceFactory: () => ServiceFactory<PluginEndpointDiscovery, "plugin">;

/**
 * An HTTP server extended with utility methods.
 *
 * @public
 */
export declare interface ExtendedHttpServer extends http.Server {
    start(): Promise<void>;
    stop(): Promise<void>;
    port(): number;
}

/**
 * @public
 */
export declare interface HttpRouterFactoryOptions {
    /**
     * A callback used to generate the path for each plugin, defaults to `/api/{pluginId}`.
     */
    getPath?(pluginId: string): string;
}

/** @public */
export declare const httpRouterServiceFactory: (options?: HttpRouterFactoryOptions | undefined) => ServiceFactory<HttpRouterService, "plugin">;

/**
 * Options for configuring HTTPS for an HTTP server.
 *
 * @public
 */
export declare type HttpServerCertificateOptions = {
    type: 'pem';
    key: string;
    cert: string;
} | {
    type: 'generated';
    hostname: string;
};

/**
 * Options for starting up an HTTP server.
 *
 * @public
 */
export declare type HttpServerOptions = {
    listen: {
        port: number;
        host: string;
    };
    https?: {
        certificate: HttpServerCertificateOptions;
    };
};

/**
 * An identity client options object which allows extra configurations
 *
 * @public
 */
export declare type IdentityFactoryOptions = {
    issuer?: string;
    /** JWS "alg" (Algorithm) Header Parameter values. Defaults to an array containing just ES256.
     * More info on supported algorithms: https://github.com/panva/jose */
    algorithms?: string[];
};

/** @public */
export declare const identityServiceFactory: (options?: IdentityFactoryOptions | undefined) => ServiceFactory<IdentityService, "plugin">;

/**
 * Allows plugins to register shutdown hooks that are run when the process is about to exit.
 * @public
 */
export declare const lifecycleServiceFactory: () => ServiceFactory<LifecycleService, "plugin">;

/**
 * Load configuration for a Backend.
 *
 * This function should only be called once, during the initialization of the backend.
 *
 * @public
 */
export declare function loadBackendConfig(options: {
    remote?: LoadConfigOptionsRemote;
    argv: string[];
}): Promise<{
    config: Config;
}>;

/** @public */
export declare const loggerServiceFactory: () => ServiceFactory<LoggerService, "plugin">;

/**
 * A utility to configure common middleware.
 *
 * @public
 */
export declare class MiddlewareFactory {
    #private;
    /**
     * Creates a new {@link MiddlewareFactory}.
     */
    static create(options: MiddlewareFactoryOptions): MiddlewareFactory;
    private constructor();
    /**
     * Returns a middleware that unconditionally produces a 404 error response.
     *
     * @remarks
     *
     * Typically you want to place this middleware at the end of the chain, such
     * that it's the last one attempted after no other routes matched.
     *
     * @returns An Express request handler
     */
    notFound(): RequestHandler;
    /**
     * Returns the compression middleware.
     *
     * @remarks
     *
     * The middleware will attempt to compress response bodies for all requests
     * that traverse through the middleware.
     */
    compression(): RequestHandler;
    /**
     * Returns a request logging middleware.
     *
     * @remarks
     *
     * Typically you want to place this middleware at the start of the chain, such
     * that it always logs requests whether they are "caught" by handlers farther
     * down or not.
     *
     * @returns An Express request handler
     */
    logging(): RequestHandler;
    /**
     * Returns a middleware that implements the helmet library.
     *
     * @remarks
     *
     * This middleware applies security policies to incoming requests and outgoing
     * responses. It is configured using config keys such as `backend.csp`.
     *
     * @see {@link https://helmetjs.github.io/}
     *
     * @returns An Express request handler
     */
    helmet(): RequestHandler;
    /**
     * Returns a middleware that implements the cors library.
     *
     * @remarks
     *
     * This middleware handles CORS. It is configured using the config key
     * `backend.cors`.
     *
     * @see {@link https://github.com/expressjs/cors}
     *
     * @returns An Express request handler
     */
    cors(): RequestHandler;
    /**
     * Express middleware to handle errors during request processing.
     *
     * @remarks
     *
     * This is commonly the very last middleware in the chain.
     *
     * Its primary purpose is not to do translation of business logic exceptions,
     * but rather to be a global catch-all for uncaught "fatal" errors that are
     * expected to result in a 500 error. However, it also does handle some common
     * error types (such as http-error exceptions, and the well-known error types
     * in the `@backstage/errors` package) and returns the enclosed status code
     * accordingly.
     *
     * It will also produce a response body with a serialized form of the error,
     * unless a previous handler already did send a body. See
     * {@link @backstage/errors#ErrorResponseBody} for the response shape used.
     *
     * @returns An Express error request handler
     */
    error(options?: MiddlewareFactoryErrorOptions): ErrorRequestHandler;
}

/**
 * Options passed to the {@link MiddlewareFactory.error} middleware.
 *
 * @public
 */
export declare interface MiddlewareFactoryErrorOptions {
    /**
     * Whether error response bodies should show error stack traces or not.
     *
     * If not specified, by default shows stack traces only in development mode.
     */
    showStackTraces?: boolean;
    /**
     * Whether any 4xx errors should be logged or not.
     *
     * If not specified, default to only logging 5xx errors.
     */
    logAllErrors?: boolean;
}

/**
 * Options used to create a {@link MiddlewareFactory}.
 *
 * @public
 */
export declare interface MiddlewareFactoryOptions {
    config: ConfigService;
    logger: LoggerService;
}

/** @public */
export declare const permissionsServiceFactory: () => ServiceFactory<PermissionsService, "plugin">;

/**
 * Attempts to read a CORS options object from the backend configuration object.
 *
 * @public
 * @param config - The backend configuration object.
 * @returns A CORS options object, or undefined if no cors configuration is present.
 *
 * @example
 * ```ts
 * const corsOptions = readCorsOptions(config.getConfig('backend'));
 * ```
 */
export declare function readCorsOptions(config?: Config): CorsOptions;

/**
 * Attempts to read Helmet options from the backend configuration object.
 *
 * @public
 * @param config - The backend configuration object.
 * @returns A Helmet options object, or undefined if no Helmet configuration is present.
 *
 * @example
 * ```ts
 * const helmetOptions = readHelmetOptions(config.getConfig('backend'));
 * ```
 */
export declare function readHelmetOptions(config?: Config): HelmetOptions;

/**
 * Reads {@link HttpServerOptions} from a {@link @backstage/config#Config} object.
 *
 * @public
 * @remarks
 *
 * The provided configuration object should contain the `listen` and
 * additional keys directly.
 *
 * @example
 * ```ts
 * const opts = readHttpServerOptions(config.getConfig('backend'));
 * ```
 */
export declare function readHttpServerOptions(config?: Config): HttpServerOptions;

/**
 * @public
 */
export declare interface RootHttpRouterConfigureContext {
    app: Express_2;
    middleware: MiddlewareFactory;
    routes: RequestHandler;
    config: ConfigService;
    logger: LoggerService;
    lifecycle: LifecycleService;
}

/**
 * @public
 */
export declare type RootHttpRouterFactoryOptions = {
    /**
     * The path to forward all unmatched requests to. Defaults to '/api/app' if
     * not given. Disables index path behavior if false is given.
     */
    indexPath?: string | false;
    configure?(context: RootHttpRouterConfigureContext): void;
};

/** @public */
export declare const rootHttpRouterServiceFactory: (options?: RootHttpRouterFactoryOptions | undefined) => ServiceFactory<RootHttpRouterService, "root">;

/**
 * Allows plugins to register shutdown hooks that are run when the process is about to exit.
 *
 * @public
 */
export declare const rootLifecycleServiceFactory: () => ServiceFactory<RootLifecycleService, "root">;

/** @public */
export declare const rootLoggerServiceFactory: () => ServiceFactory<RootLoggerService, "root">;

/** @public */
export declare const schedulerServiceFactory: () => ServiceFactory<SchedulerService, "plugin">;

/** @public */
export declare const tokenManagerServiceFactory: () => ServiceFactory<TokenManagerService, "plugin">;

/** @public */
export declare const urlReaderServiceFactory: () => ServiceFactory<UrlReader, "plugin">;

/**
 * A {@link @backstage/backend-plugin-api#LoggerService} implementation based on winston.
 *
 * @public
 */
export declare class WinstonLogger implements RootLoggerService {
    #private;
    /**
     * Creates a {@link WinstonLogger} instance.
     */
    static create(options: WinstonLoggerOptions): WinstonLogger;
    /**
     * Creates a winston log formatter for redacting secrets.
     */
    static redacter(): {
        format: Format;
        add: (redactions: Iterable<string>) => void;
    };
    /**
     * Creates a pretty printed winston log formatter.
     */
    static colorFormat(): Format;
    private constructor();
    error(message: string, meta?: JsonObject): void;
    warn(message: string, meta?: JsonObject): void;
    info(message: string, meta?: JsonObject): void;
    debug(message: string, meta?: JsonObject): void;
    child(meta: JsonObject): LoggerService;
    addRedactions(redactions: Iterable<string>): void;
}

/**
 * @public
 */
export declare interface WinstonLoggerOptions {
    meta?: JsonObject;
    level: string;
    format: Format;
    transports: transport[];
}

export { }
