import React, { useCallback, useState } from 'react';
import { Link, useNavigate, Navigate, useOutlet, Routes, Route } from 'react-router-dom';
import { Progress, Link as Link$1, DocsIcon, Page, Header, Content, ContentHeader, SupportButton, ErrorPage } from '@backstage/core-components';
import { useEntityTypeFilter, useEntityList, EntityListProvider, CatalogFilterLayout, EntitySearchBar, EntityKindPicker, UserListPicker, EntityTagPicker } from '@backstage/plugin-catalog-react';
import capitalize from 'lodash/capitalize';
import { Box, Typography, FormControlLabel, Checkbox, TextField } from '@material-ui/core';
import CheckBoxIcon from '@material-ui/icons/CheckBox';
import CheckBoxOutlineBlankIcon from '@material-ui/icons/CheckBoxOutlineBlank';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import { Autocomplete } from '@material-ui/lab';
import { useApi, alertApiRef, errorApiRef, useApp, useRouteRef, useRouteRefParams, AnalyticsContext } from '@backstage/core-plugin-api';
import Button from '@material-ui/core/Button';
import IconButton from '@material-ui/core/IconButton';
import useMediaQuery from '@material-ui/core/useMediaQuery';
import AddCircleOutline from '@material-ui/icons/AddCircleOutline';
import { catalogEntityCreatePermission } from '@backstage/plugin-catalog-common';
import { usePermission } from '@backstage/plugin-permission-react';
import { parseEntityRef, stringifyEntityRef } from '@backstage/catalog-model';
import { TemplateGroup, useTemplateSecrets, scaffolderApiRef, Workflow, useCustomFieldExtensions, useCustomLayouts, SecretsContextProvider } from '@backstage/plugin-scaffolder-react';
import { v as viewTechDocRouteRef, G as nextSelectedTemplateRouteRef, r as registerComponentRouteRef, H as ContextMenu, I as nextRouteRef, J as nextScaffolderTaskRouteRef, K as TemplateEditor, L as TemplateFormPreviewer, M as CustomFieldExplorer, k as TemplateEditorIntro, W as WebFileSystemAccess, N as nextEditRouteRef, P as nextActionsRouteRef, A as ActionsPage, Q as nextScaffolderListTaskRouteRef, S as OngoingTask } from './index-5b3a75fa.esm.js';
import { D as DEFAULT_SCAFFOLDER_FIELD_EXTENSIONS, L as ListTasksPage } from './ListTasksPage-a0fe74a9.esm.js';
import '@backstage/errors';
import 'qs';
import 'zen-observable';
import '@backstage/integration-react';
import '@material-ui/core/FormControl';
import '@material-ui/lab/Autocomplete';
import 'react-use/lib/useAsync';
import 'zod';
import 'zod-to-json-schema';
import '@material-ui/core/FormHelperText';
import '@material-ui/core/Input';
import '@material-ui/core/InputLabel';
import 'react-use/lib/useDebounce';
import 'react-use/lib/useEffectOnce';
import '@material-ui/core/ListItemIcon';
import '@material-ui/core/ListItemText';
import '@material-ui/core/MenuItem';
import '@material-ui/core/MenuList';
import '@material-ui/core/Popover';
import '@material-ui/core/styles';
import '@material-ui/icons/Description';
import '@material-ui/icons/Edit';
import '@material-ui/icons/List';
import '@material-ui/icons/MoreVert';
import 'use-immer';
import '@material-ui/icons/RemoveCircleOutline';
import '@material-ui/icons/PanoramaFishEye';
import 'classnames';
import '@material-ui/icons/CheckCircleOutline';
import '@material-ui/icons/ErrorOutline';
import 'react-use/lib/useInterval';
import 'luxon';
import 'humanize-duration';
import '@react-hookz/web';
import '@material-ui/icons/Repeat';
import '@material-ui/icons/Toc';
import '@material-ui/icons/Settings';
import '@material-ui/icons/FontDownload';
import '@material-ui/core/Typography';
import '@codemirror/language';
import '@codemirror/legacy-modes/mode/yaml';
import '@material-ui/icons/Close';
import '@uiw/react-codemirror';
import 'yaml';
import '@rjsf/validator-ajv8';
import '@material-ui/core/Accordion';
import '@material-ui/core/AccordionDetails';
import '@material-ui/core/AccordionSummary';
import '@material-ui/core/Divider';
import '@material-ui/icons/ExpandLess';
import '@material-ui/core/List';
import '@material-ui/core/ListItem';
import '@material-ui/core/ListItemSecondaryAction';
import '@material-ui/icons/Cancel';
import '@material-ui/icons/Check';
import '@material-ui/icons/Delete';
import '@material-ui/core/Box';
import '@material-ui/core/Tab';
import '@material-ui/core/Tabs';
import '@material-ui/core/Grid';
import '@material-ui/core/Step';
import '@material-ui/core/StepLabel';
import '@material-ui/core/Stepper';
import '@material-ui/icons/FiberManualRecord';
import '@material-ui/icons/Language';
import '@material-ui/lab/TreeView';
import '@material-ui/icons/ChevronRight';
import '@material-ui/lab/TreeItem';
import '@material-ui/icons/Refresh';
import '@material-ui/icons/Save';
import '@codemirror/view';
import '@material-ui/core/Card';
import '@material-ui/core/CardActionArea';
import '@material-ui/core/CardContent';
import '@material-ui/core/Tooltip';
import '@material-ui/icons/InfoOutlined';

const icon = /* @__PURE__ */ React.createElement(CheckBoxOutlineBlankIcon, { fontSize: "small" });
const checkedIcon = /* @__PURE__ */ React.createElement(CheckBoxIcon, { fontSize: "small" });
const CategoryPicker = () => {
  const alertApi = useApi(alertApiRef);
  const { error, loading, availableTypes, selectedTypes, setSelectedTypes } = useEntityTypeFilter();
  if (loading)
    return /* @__PURE__ */ React.createElement(Progress, null);
  if (error) {
    alertApi.post({
      message: `Failed to load entity types with error: ${error}`,
      severity: "error"
    });
    return null;
  }
  if (!availableTypes)
    return null;
  return /* @__PURE__ */ React.createElement(Box, { pb: 1, pt: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "button" }, "Categories"), /* @__PURE__ */ React.createElement(
    Autocomplete,
    {
      multiple: true,
      "aria-label": "Categories",
      options: availableTypes,
      value: selectedTypes,
      onChange: (_, value) => setSelectedTypes(value),
      renderOption: (option, { selected }) => /* @__PURE__ */ React.createElement(
        FormControlLabel,
        {
          control: /* @__PURE__ */ React.createElement(
            Checkbox,
            {
              icon,
              checkedIcon,
              checked: selected
            }
          ),
          label: capitalize(option)
        }
      ),
      size: "small",
      popupIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, null),
      renderInput: (params) => /* @__PURE__ */ React.createElement(TextField, { ...params, variant: "outlined" })
    }
  ));
};

const RegisterExistingButton = (props) => {
  const { title, to } = props;
  const { allowed } = usePermission({
    permission: catalogEntityCreatePermission
  });
  const isXSScreen = useMediaQuery(
    (theme) => theme.breakpoints.down("xs")
  );
  if (!to || !allowed) {
    return null;
  }
  return isXSScreen ? /* @__PURE__ */ React.createElement(
    IconButton,
    {
      component: Link,
      color: "primary",
      title,
      size: "small",
      to
    },
    /* @__PURE__ */ React.createElement(AddCircleOutline, null)
  ) : /* @__PURE__ */ React.createElement(Button, { component: Link, variant: "contained", color: "primary", to }, title);
};

const TemplateGroups = (props) => {
  const { loading, error, entities } = useEntityList();
  const { groups, TemplateCardComponent } = props;
  const errorApi = useApi(errorApiRef);
  const app = useApp();
  const viewTechDocsLink = useRouteRef(viewTechDocRouteRef);
  const templateRoute = useRouteRef(nextSelectedTemplateRouteRef);
  const navigate = useNavigate();
  const onSelected = useCallback(
    (template) => {
      const { namespace, name } = parseEntityRef(stringifyEntityRef(template));
      navigate(templateRoute({ namespace, templateName: name }));
    },
    [navigate, templateRoute]
  );
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  if (error) {
    errorApi.post(error);
    return null;
  }
  if (!entities || !entities.length) {
    return /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "No templates found that match your filter. Learn more about", " ", /* @__PURE__ */ React.createElement(Link$1, { to: "https://backstage.io/docs/features/software-templates/adding-templates" }, "adding templates"), ".");
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, groups.map(({ title, filter }, index) => {
    const templates = entities.filter((e) => filter(e)).map((template) => {
      var _a, _b;
      const { kind, namespace, name } = parseEntityRef(
        stringifyEntityRef(template)
      );
      const additionalLinks = ((_a = template.metadata.annotations) == null ? void 0 : _a["backstage.io/techdocs-ref"]) && viewTechDocsLink ? [
        {
          icon: (_b = app.getSystemIcon("docs")) != null ? _b : DocsIcon,
          text: "View TechDocs",
          url: viewTechDocsLink({ kind, namespace, name })
        }
      ] : [];
      return {
        template,
        additionalLinks
      };
    });
    return /* @__PURE__ */ React.createElement(
      TemplateGroup,
      {
        key: index,
        templates,
        title,
        components: { CardComponent: TemplateCardComponent },
        onSelected
      }
    );
  }));
};

const defaultGroup = {
  title: "All Templates",
  filter: () => true
};
const TemplateListPage = (props) => {
  const registerComponentLink = useRouteRef(registerComponentRouteRef);
  const { TemplateCardComponent, groups = [] } = props;
  return /* @__PURE__ */ React.createElement(EntityListProvider, null, /* @__PURE__ */ React.createElement(Page, { themeId: "website" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: "Create a new component",
      title: "Create a new component",
      subtitle: "Create new software components using standard templates in your organization"
    },
    /* @__PURE__ */ React.createElement(ContextMenu, { ...props.contextMenu })
  ), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ContentHeader, { title: "Available Templates" }, /* @__PURE__ */ React.createElement(
    RegisterExistingButton,
    {
      title: "Register Existing Component",
      to: registerComponentLink && registerComponentLink()
    }
  ), /* @__PURE__ */ React.createElement(SupportButton, null, "Create new software components using standard templates. Different templates create different kinds of components (services, websites, documentation, ...).")), /* @__PURE__ */ React.createElement(CatalogFilterLayout, null, /* @__PURE__ */ React.createElement(CatalogFilterLayout.Filters, null, /* @__PURE__ */ React.createElement(EntitySearchBar, null), /* @__PURE__ */ React.createElement(EntityKindPicker, { initialFilter: "template", hidden: true }), /* @__PURE__ */ React.createElement(
    UserListPicker,
    {
      initialFilter: "all",
      availableFilters: ["all", "starred"]
    }
  ), /* @__PURE__ */ React.createElement(CategoryPicker, null), /* @__PURE__ */ React.createElement(EntityTagPicker, null)), /* @__PURE__ */ React.createElement(CatalogFilterLayout.Content, null, /* @__PURE__ */ React.createElement(
    TemplateGroups,
    {
      groups: [...groups, defaultGroup],
      TemplateCardComponent
    }
  ))))));
};

const TemplateWizardPage = (props) => {
  const rootRef = useRouteRef(nextRouteRef);
  const taskRoute = useRouteRef(nextScaffolderTaskRouteRef);
  const { secrets } = useTemplateSecrets();
  const scaffolderApi = useApi(scaffolderApiRef);
  const navigate = useNavigate();
  const { templateName, namespace } = useRouteRefParams(
    nextSelectedTemplateRouteRef
  );
  const templateRef = stringifyEntityRef({
    kind: "Template",
    namespace,
    name: templateName
  });
  const onCreate = async (values) => {
    const { taskId } = await scaffolderApi.scaffold({
      templateRef,
      values,
      secrets
    });
    navigate(taskRoute({ taskId }));
  };
  const onError = () => /* @__PURE__ */ React.createElement(Navigate, { to: rootRef() });
  return /* @__PURE__ */ React.createElement(AnalyticsContext, { attributes: { entityRef: templateRef } }, /* @__PURE__ */ React.createElement(Page, { themeId: "website" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: "Create a new component",
      title: "Create a new component",
      subtitle: "Create new software components using standard templates in your organization"
    }
  ), /* @__PURE__ */ React.createElement(
    Workflow,
    {
      namespace,
      templateName,
      onCreate,
      onError,
      extensions: props.customFieldExtensions,
      FormProps: props.FormProps,
      layouts: props.layouts
    }
  )));
};

function TemplateEditorPage(props) {
  const [selection, setSelection] = useState();
  let content = null;
  if ((selection == null ? void 0 : selection.type) === "local") {
    content = /* @__PURE__ */ React.createElement(
      TemplateEditor,
      {
        directory: selection.directory,
        fieldExtensions: props.customFieldExtensions,
        onClose: () => setSelection(void 0),
        layouts: props.layouts
      }
    );
  } else if ((selection == null ? void 0 : selection.type) === "form") {
    content = /* @__PURE__ */ React.createElement(
      TemplateFormPreviewer,
      {
        defaultPreviewTemplate: props.defaultPreviewTemplate,
        customFieldExtensions: props.customFieldExtensions,
        onClose: () => setSelection(void 0),
        layouts: props.layouts
      }
    );
  } else if ((selection == null ? void 0 : selection.type) === "field-explorer") {
    content = /* @__PURE__ */ React.createElement(
      CustomFieldExplorer,
      {
        customFieldExtensions: props.customFieldExtensions,
        onClose: () => setSelection(void 0)
      }
    );
  } else {
    content = /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(
      TemplateEditorIntro,
      {
        onSelect: (option) => {
          if (option === "local") {
            WebFileSystemAccess.requestDirectoryAccess().then((directory) => setSelection({ type: "local", directory })).catch(() => {
            });
          } else if (option === "form") {
            setSelection({ type: "form" });
          } else if (option === "field-explorer") {
            setSelection({ type: "field-explorer" });
          }
        }
      }
    ));
  }
  return /* @__PURE__ */ React.createElement(Page, { themeId: "home" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      title: "Template Editor",
      subtitle: "Edit, preview, and try out templates and template forms"
    }
  ), content);
}

const Router = (props) => {
  const {
    components: {
      TemplateCardComponent,
      TemplateOutputsComponent,
      TaskPageComponent = OngoingTask
    } = {}
  } = props;
  const outlet = useOutlet() || props.children;
  const customFieldExtensions = useCustomFieldExtensions(outlet);
  const fieldExtensions = [
    ...customFieldExtensions,
    ...DEFAULT_SCAFFOLDER_FIELD_EXTENSIONS.filter(
      ({ name }) => !customFieldExtensions.some(
        (customFieldExtension) => customFieldExtension.name === name
      )
    )
  ];
  const customLayouts = useCustomLayouts(outlet);
  return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(
    Route,
    {
      path: "/",
      element: /* @__PURE__ */ React.createElement(
        TemplateListPage,
        {
          TemplateCardComponent,
          contextMenu: props.contextMenu,
          groups: props.groups
        }
      )
    }
  ), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: nextSelectedTemplateRouteRef.path,
      element: /* @__PURE__ */ React.createElement(SecretsContextProvider, null, /* @__PURE__ */ React.createElement(
        TemplateWizardPage,
        {
          customFieldExtensions: fieldExtensions,
          layouts: customLayouts,
          FormProps: props.FormProps
        }
      ))
    }
  ), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: nextScaffolderTaskRouteRef.path,
      element: /* @__PURE__ */ React.createElement(
        TaskPageComponent,
        {
          TemplateOutputsComponent
        }
      )
    }
  ), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: nextEditRouteRef.path,
      element: /* @__PURE__ */ React.createElement(SecretsContextProvider, null, /* @__PURE__ */ React.createElement(
        TemplateEditorPage,
        {
          customFieldExtensions: fieldExtensions,
          layouts: customLayouts
        }
      ))
    }
  ), /* @__PURE__ */ React.createElement(Route, { path: nextActionsRouteRef.path, element: /* @__PURE__ */ React.createElement(ActionsPage, null) }), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: nextScaffolderListTaskRouteRef.path,
      element: /* @__PURE__ */ React.createElement(ListTasksPage, null)
    }
  ), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: "*",
      element: /* @__PURE__ */ React.createElement(ErrorPage, { status: "404", statusMessage: "Page not found" })
    }
  ));
};

export { Router };
//# sourceMappingURL=index-83c9fe8a.esm.js.map
