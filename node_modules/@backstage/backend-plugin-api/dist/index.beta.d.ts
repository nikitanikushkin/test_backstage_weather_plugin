/**
 * Core API used by Backstage backend plugins.
 *
 * @packageDocumentation
 */

/// <reference types="node" />

import { Config } from '@backstage/config';
import { Handler } from 'express';
import { IdentityApi } from '@backstage/plugin-auth-node';
import { JsonObject } from '@backstage/types';
import { JsonValue } from '@backstage/types';
import { Knex } from 'knex';
import { PermissionEvaluator } from '@backstage/plugin-permission-common';
import { PluginTaskScheduler } from '@backstage/backend-tasks';
import { Readable } from 'stream';

/** @public */
export declare interface BackendFeature {
    $$type: '@backstage/BackendFeature';
}

/**
 * The configuration options passed to {@link createBackendModule}.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/modules | The architecture of modules}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
export declare interface BackendModuleConfig {
    /**
     * The ID of this plugin.
     *
     * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
     */
    pluginId: string;
    /**
     * Should exactly match the `id` of the plugin that the module extends.
     */
    moduleId: string;
    register(reg: BackendModuleRegistrationPoints): void;
}

/**
 * The callbacks passed to the `register` method of a backend module.
 *
 * @public
 */
export declare interface BackendModuleRegistrationPoints {
    registerInit<Deps extends {
        [name in string]: unknown;
    }>(options: {
        deps: {
            [name in keyof Deps]: ServiceRef<Deps[name]> | ExtensionPoint<Deps[name]>;
        };
        init(deps: Deps): Promise<void>;
    }): void;
}

/**
 * The configuration options passed to {@link createBackendPlugin}.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/plugins | The architecture of plugins}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
export declare interface BackendPluginConfig {
    /**
     * The ID of this plugin.
     *
     * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
     */
    pluginId: string;
    register(reg: BackendPluginRegistrationPoints): void;
}

/**
 * The callbacks passed to the `register` method of a backend plugin.
 *
 * @public
 */
export declare interface BackendPluginRegistrationPoints {
    registerExtensionPoint<TExtensionPoint>(ref: ExtensionPoint<TExtensionPoint>, impl: TExtensionPoint): void;
    registerInit<Deps extends {
        [name in string]: unknown;
    }>(options: {
        deps: {
            [name in keyof Deps]: ServiceRef<Deps[name]>;
        };
        init(deps: Deps): Promise<void>;
    }): void;
}

/**
 * A pre-configured, storage agnostic cache service suitable for use by
 * Backstage plugins.
 *
 * @public
 */
export declare interface CacheService {
    /**
     * Reads data from a cache store for the given key. If no data was found,
     * returns undefined.
     */
    get<TValue extends JsonValue>(key: string): Promise<TValue | undefined>;
    /**
     * Writes the given data to a cache store, associated with the given key. An
     * optional TTL may also be provided, otherwise it defaults to the TTL that
     * was provided when the client was instantiated.
     */
    set(key: string, value: JsonValue, options?: CacheServiceSetOptions): Promise<void>;
    /**
     * Removes the given key from the cache store.
     */
    delete(key: string): Promise<void>;
    /**
     * Creates a new {@link CacheService} instance with the given options.
     */
    withOptions(options: CacheServiceOptions): CacheService;
}

/**
 * Options passed to {@link CacheService.withOptions}.
 *
 * @public
 */
export declare type CacheServiceOptions = {
    /**
     * An optional default TTL (in milliseconds) to be set when getting a client
     * instance. If not provided, data will persist indefinitely by default (or
     * can be configured per entry at set-time).
     */
    defaultTtl?: number;
};

/**
 * Options passed to {@link CacheService.set}.
 *
 * @public
 */
export declare type CacheServiceSetOptions = {
    /**
     * Optional TTL in milliseconds. Defaults to the TTL provided when the client
     * was set up (or no TTL if none are provided).
     */
    ttl?: number;
};

/**
 * @public
 */
export declare interface ConfigService extends Config {
}

/**
 * All core services references
 *
 * @public
 */
export declare namespace coreServices {
    /**
     * The service reference for the plugin scoped {@link CacheService}.
     *
     * @public
     */
    const cache: ServiceRef<CacheService, "plugin">;
    /**
     * The service reference for the root scoped {@link ConfigService}.
     *
     * @public
     */
    const config: ServiceRef<ConfigService, "root">;
    /**
     * The service reference for the plugin scoped {@link DatabaseService}.
     *
     * @public
     */
    const database: ServiceRef<DatabaseService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link DiscoveryService}.
     *
     * @public
     */
    const discovery: ServiceRef<DiscoveryService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link HttpRouterService}.
     *
     * @public
     */
    const httpRouter: ServiceRef<HttpRouterService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link LifecycleService}.
     *
     * @public
     */
    const lifecycle: ServiceRef<LifecycleService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link LoggerService}.
     *
     * @public
     */
    const logger: ServiceRef<LoggerService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link PermissionsService}.
     *
     * @public
     */
    const permissions: ServiceRef<PermissionsService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link PluginMetadataService}.
     *
     * @public
     */
    const pluginMetadata: ServiceRef<PluginMetadataService, "plugin">;
    /**
     * The service reference for the root scoped {@link RootHttpRouterService}.
     *
     * @public
     */
    const rootHttpRouter: ServiceRef<RootHttpRouterService, "root">;
    /**
     * The service reference for the root scoped {@link RootLifecycleService}.
     *
     * @public
     */
    const rootLifecycle: ServiceRef<RootLifecycleService, "root">;
    /**
     * The service reference for the root scoped {@link RootLoggerService}.
     *
     * @public
     */
    const rootLogger: ServiceRef<RootLoggerService, "root">;
    /**
     * The service reference for the plugin scoped {@link SchedulerService}.
     *
     * @public
     */
    const scheduler: ServiceRef<SchedulerService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link TokenManagerService}.
     *
     * @public
     */
    const tokenManager: ServiceRef<TokenManagerService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link UrlReaderService}.
     *
     * @public
     */
    const urlReader: ServiceRef<UrlReaderService, "plugin">;
    /**
     * The service reference for the plugin scoped {@link IdentityService}.
     *
     * @public
     */
    const identity: ServiceRef<IdentityService, "plugin">;
}

/**
 * Creates a new backend module for a given plugin.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/modules | The architecture of modules}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
export declare function createBackendModule<TOptions extends [options?: object] = []>(config: BackendModuleConfig | ((...params: TOptions) => BackendModuleConfig)): (...params: TOptions) => BackendFeature;

/**
 * Creates a new backend plugin.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/plugins | The architecture of plugins}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
export declare function createBackendPlugin<TOptions extends [options?: object] = []>(config: BackendPluginConfig | ((...params: TOptions) => BackendPluginConfig)): (...params: TOptions) => BackendFeature;

/**
 * Creates a new backend extension point.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/extension-points | The architecture of extension points}
 */
export declare function createExtensionPoint<T>(config: ExtensionPointConfig): ExtensionPoint<T>;

/**
 * Creates a root scoped service factory without options.
 *
 * @public
 * @param config - The service factory configuration.
 */
export declare function createServiceFactory<TService, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TOpts extends object | undefined = undefined>(config: RootServiceFactoryConfig<TService, TImpl, TDeps>): () => ServiceFactory<TService, 'root'>;

/**
 * Creates a root scoped service factory with optional options.
 *
 * @public
 * @param config - The service factory configuration.
 */
export declare function createServiceFactory<TService, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TOpts extends object | undefined = undefined>(config: (options?: TOpts) => RootServiceFactoryConfig<TService, TImpl, TDeps>): (options?: TOpts) => ServiceFactory<TService, 'root'>;

/**
 * Creates a root scoped service factory with required options.
 *
 * @public
 * @param config - The service factory configuration.
 */
export declare function createServiceFactory<TService, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TOpts extends object | undefined = undefined>(config: (options: TOpts) => RootServiceFactoryConfig<TService, TImpl, TDeps>): (options: TOpts) => ServiceFactory<TService, 'root'>;

/**
 * Creates a plugin scoped service factory without options.
 *
 * @public
 * @param config - The service factory configuration.
 */
export declare function createServiceFactory<TService, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TContext = undefined, TOpts extends object | undefined = undefined>(config: PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps>): () => ServiceFactory<TService, 'plugin'>;

/**
 * Creates a plugin scoped service factory with optional options.
 *
 * @public
 * @param config - The service factory configuration.
 */
export declare function createServiceFactory<TService, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TContext = undefined, TOpts extends object | undefined = undefined>(config: (options?: TOpts) => PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps>): (options?: TOpts) => ServiceFactory<TService, 'plugin'>;

/**
 * Creates a plugin scoped service factory with required options.
 *
 * @public
 * @param config - The service factory configuration.
 */
export declare function createServiceFactory<TService, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TContext = undefined, TOpts extends object | undefined = undefined>(config: PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps> | ((options: TOpts) => PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps>)): (options: TOpts) => ServiceFactory<TService, 'plugin'>;

/**
 * Creates a new service definition. This overload is used to create plugin scoped services.
 *
 * @public
 */
export declare function createServiceRef<TService>(config: ServiceRefConfig<TService, 'plugin'>): ServiceRef<TService, 'plugin'>;

/**
 * Creates a new service definition. This overload is used to create root scoped services.
 *
 * @public
 */
export declare function createServiceRef<TService>(config: ServiceRefConfig<TService, 'root'>): ServiceRef<TService, 'root'>;

/**
 * Creates a shared backend environment which can be used to create multiple
 * backends.
 *
 * @public
 */
export declare function createSharedEnvironment<TOptions extends [options?: object] = []>(config: SharedBackendEnvironmentConfig | ((...params: TOptions) => SharedBackendEnvironmentConfig)): (...options: TOptions) => SharedBackendEnvironment;

/**
 * The DatabaseService manages access to databases that Plugins get.
 *
 * @public
 */
export declare interface DatabaseService {
    /**
     * getClient provides backend plugins database connections for itself.
     *
     * The purpose of this method is to allow plugins to get isolated data
     * stores so that plugins are discouraged from database integration.
     */
    getClient(): Promise<Knex>;
    /**
     * This property is used to control the behavior of database migrations.
     */
    migrations?: {
        /**
         * skip database migrations. Useful if connecting to a read-only database.
         *
         * @defaultValue false
         */
        skip?: boolean;
    };
}

/**
 * The DiscoveryService is used to provide a mechanism for backend
 * plugins to discover the endpoints for itself or other backend plugins.
 *
 * The purpose of the discovery API is to allow for many different deployment
 * setups and routing methods through a central configuration, instead
 * of letting each individual plugin manage that configuration.
 *
 * Implementations of the discovery API can be as simple as a URL pattern
 * using the pluginId, but could also have overrides for individual plugins,
 * or query a separate discovery service.
 *
 * @public
 */
export declare interface DiscoveryService {
    /**
     * Returns the internal HTTP base URL for a given plugin, without a trailing slash.
     *
     * The returned URL should point to an internal endpoint for the plugin, with
     * the shortest route possible. The URL should be used for service-to-service
     * communication within a Backstage backend deployment.
     *
     * This method must always be called just before making a request, as opposed to
     * fetching the URL when constructing an API client. That is to ensure that more
     * flexible routing patterns can be supported.
     *
     * For example, asking for the URL for `catalog` may return something
     * like `http://10.1.2.3/api/catalog`
     */
    getBaseUrl(pluginId: string): Promise<string>;
    /**
     * Returns the external HTTP base backend URL for a given plugin, without a trailing slash.
     *
     * The returned URL should point to an external endpoint for the plugin, such that
     * it is reachable from the Backstage frontend and other external services. The returned
     * URL should be usable for example as a callback / webhook URL.
     *
     * The returned URL should be stable and in general not change unless other static
     * or external configuration is changed. Changes should not come as a surprise
     * to an operator of the Backstage backend.
     *
     * For example, asking for the URL for `catalog` may return something
     * like `https://backstage.example.com/api/catalog`
     */
    getExternalBaseUrl(pluginId: string): Promise<string>;
}

/**
 * TODO
 *
 * @public
 */
export declare type ExtensionPoint<T> = {
    id: string;
    /**
     * Utility for getting the type of the extension point, using `typeof extensionPoint.T`.
     * Attempting to actually read this value will result in an exception.
     */
    T: T;
    toString(): string;
    $$type: '@backstage/ExtensionPoint';
};

/**
 * The configuration options passed to {@link createExtensionPoint}.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/extension-points | The architecture of extension points}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
export declare interface ExtensionPointConfig {
    /**
     * The ID of this extension point.
     *
     * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
     */
    id: string;
}

/**
 * @public
 */
export declare interface HttpRouterService {
    use(handler: Handler): void;
}

/** @public */
export declare interface IdentityService extends IdentityApi {
}

/**
 * @public
 */
export declare interface LifecycleService {
    /**
     * Register a function to be called when the backend is shutting down.
     */
    addShutdownHook(hook: LifecycleServiceShutdownHook, options?: LifecycleServiceShutdownOptions): void;
}

/**
 * @public
 */
export declare type LifecycleServiceShutdownHook = () => void | Promise<void>;

/**
 * @public
 */
export declare interface LifecycleServiceShutdownOptions {
    /**
     * Optional {@link LoggerService} that will be used for logging instead of the default logger.
     */
    logger?: LoggerService;
}

/**
 * A service that provides a logging facility.
 *
 * @public
 */
export declare interface LoggerService {
    error(message: string, meta?: Error | JsonObject): void;
    warn(message: string, meta?: Error | JsonObject): void;
    info(message: string, meta?: Error | JsonObject): void;
    debug(message: string, meta?: Error | JsonObject): void;
    child(meta: JsonObject): LoggerService;
}

/** @public */
export declare interface PermissionsService extends PermissionEvaluator {
}

/**
 * @public
 */
export declare interface PluginMetadataService {
    getId(): string;
}

/** @public */
export declare interface PluginServiceFactoryConfig<TService, TContext, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}> {
    service: ServiceRef<TService, 'plugin'>;
    deps: TDeps;
    createRootContext?(deps: ServiceRefsToInstances<TDeps, 'root'>): TContext | Promise<TContext>;
    factory(deps: ServiceRefsToInstances<TDeps>, context: TContext): TImpl | Promise<TImpl>;
}

/**
 * An options object for {@link UrlReaderService.readTree} operations.
 *
 * @public
 */
export declare type ReadTreeOptions = {
    /**
     * A filter that can be used to select which files should be included.
     *
     * @remarks
     *
     * The path passed to the filter function is the relative path from the URL
     * that the file tree is fetched from, without any leading '/'.
     *
     * For example, given the URL https://github.com/my/repo/tree/master/my-dir, a file
     * at https://github.com/my/repo/blob/master/my-dir/my-subdir/my-file.txt will
     * be represented as my-subdir/my-file.txt
     *
     * If no filter is provided, all files are extracted.
     */
    filter?(path: string, info?: {
        size: number;
    }): boolean;
    /**
     * An ETag which can be provided to check whether a
     * {@link UrlReaderService.readTree} response has changed from a previous execution.
     *
     * @remarks
     *
     * In the {@link UrlReaderService.readTree} response, an ETag is returned along with
     * the tree blob. The ETag is a unique identifier of the tree blob, usually
     * the commit SHA or ETag from the target.
     *
     * When an ETag is given as a request option, {@link UrlReaderService.readTree} will
     * first compare the ETag against the ETag on the target branch. If they
     * match, {@link UrlReaderService.readTree} will throw a
     * {@link @backstage/errors#NotModifiedError} indicating that the response
     * will not differ from the previous response which included this particular
     * ETag. If they do not match, {@link UrlReaderService.readTree} will return the
     * rest of the response along with a new ETag.
     */
    etag?: string;
    /**
     * An abort signal to pass down to the underlying request.
     *
     * @remarks
     *
     * Not all reader implementations may take this field into account.
     */
    signal?: AbortSignal;
};

/**
 * A response object for {@link UrlReaderService.readTree} operations.
 *
 * @public
 */
export declare type ReadTreeResponse = {
    /**
     * Returns an array of all the files inside the tree, and corresponding
     * functions to read their content.
     */
    files(): Promise<ReadTreeResponseFile[]>;
    /**
     * Returns the tree contents as a binary archive, using a stream.
     */
    archive(): Promise<NodeJS.ReadableStream>;
    /**
     * Extracts the tree response into a directory and returns the path of the
     * directory.
     *
     * **NOTE**: It is the responsibility of the caller to remove the directory after use.
     */
    dir(options?: ReadTreeResponseDirOptions): Promise<string>;
    /**
     * Etag returned by content provider.
     *
     * @remarks
     *
     * Can be used to compare and cache responses when doing subsequent calls.
     */
    etag: string;
};

/**
 * Options that control {@link ReadTreeResponse.dir} execution.
 *
 * @public
 */
export declare type ReadTreeResponseDirOptions = {
    /**
     * The directory to write files to.
     *
     * @remarks
     *
     * Defaults to the OS tmpdir, or `backend.workingDirectory` if set in config.
     */
    targetDir?: string;
};

/**
 * Represents a single file in a {@link UrlReaderService.readTree} response.
 *
 * @public
 */
export declare type ReadTreeResponseFile = {
    path: string;
    content(): Promise<Buffer>;
};

/**
 * An options object for readUrl operations.
 *
 * @public
 */
export declare type ReadUrlOptions = {
    /**
     * An ETag which can be provided to check whether a
     * {@link UrlReaderService.readUrl} response has changed from a previous execution.
     *
     * @remarks
     *
     * In the {@link UrlReaderService.readUrl} response, an ETag is returned along with
     * the data. The ETag is a unique identifier of the data, usually the commit
     * SHA or ETag from the target.
     *
     * When an ETag is given in ReadUrlOptions, {@link UrlReaderService.readUrl} will
     * first compare the ETag against the ETag of the target. If they match,
     * {@link UrlReaderService.readUrl} will throw a
     * {@link @backstage/errors#NotModifiedError} indicating that the response
     * will not differ from the previous response which included this particular
     * ETag. If they do not match, {@link UrlReaderService.readUrl} will return the rest
     * of the response along with a new ETag.
     */
    etag?: string;
    /**
     * An abort signal to pass down to the underlying request.
     *
     * @remarks
     *
     * Not all reader implementations may take this field into account.
     */
    signal?: AbortSignal;
};

/**
 * A response object for {@link UrlReaderService.readUrl} operations.
 *
 * @public
 */
export declare type ReadUrlResponse = {
    /**
     * Returns the data that was read from the remote URL.
     */
    buffer(): Promise<Buffer>;
    /**
     * Returns the data that was read from the remote URL as a Readable stream.
     *
     * @remarks
     *
     * This method will be required in a future release.
     */
    stream?(): Readable;
    /**
     * Etag returned by content provider.
     *
     * @remarks
     *
     * Can be used to compare and cache responses when doing subsequent calls.
     */
    etag?: string;
};

/**
 * @public
 */
export declare interface RootHttpRouterService {
    /**
     * Registers a handler at the root of the backend router.
     * The path is required and may not be empty.
     */
    use(path: string, handler: Handler): void;
}

/** @public */
export declare interface RootLifecycleService extends LifecycleService {
}

/** @public */
export declare interface RootLoggerService extends LoggerService {
}

/** @public */
export declare interface RootServiceFactoryConfig<TService, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}> {
    service: ServiceRef<TService, 'root'>;
    deps: TDeps;
    factory(deps: ServiceRefsToInstances<TDeps, 'root'>): TImpl | Promise<TImpl>;
}

/** @public */
export declare interface SchedulerService extends PluginTaskScheduler {
}

/**
 * An options object for search operations.
 *
 * @public
 */
export declare type SearchOptions = {
    /**
     * An etag can be provided to check whether the search response has changed from a previous execution.
     *
     * In the search() response, an etag is returned along with the files. The etag is a unique identifier
     * of the current tree, usually the commit SHA or etag from the target.
     *
     * When an etag is given in SearchOptions, search will first compare the etag against the etag
     * on the target branch. If they match, search will throw a NotModifiedError indicating that the search
     * response will not differ from the previous response which included this particular etag. If they mismatch,
     * search will return the rest of SearchResponse along with a new etag.
     */
    etag?: string;
    /**
     * An abort signal to pass down to the underlying request.
     *
     * @remarks
     *
     * Not all reader implementations may take this field into account.
     */
    signal?: AbortSignal;
};

/**
 * The output of a search operation.
 *
 * @public
 */
export declare type SearchResponse = {
    /**
     * The files that matched the search query.
     */
    files: SearchResponseFile[];
    /**
     * A unique identifier of the current remote tree, usually the commit SHA or etag from the target.
     */
    etag: string;
};

/**
 * Represents a single file in a search response.
 *
 * @public
 */
export declare type SearchResponseFile = {
    /**
     * The full URL to the file.
     */
    url: string;
    /**
     * The binary contents of the file.
     */
    content(): Promise<Buffer>;
};

/** @public */
export declare interface ServiceFactory<TService = unknown, TScope extends 'plugin' | 'root' = 'plugin' | 'root'> {
    $$type: '@backstage/ServiceFactory';
    service: ServiceRef<TService, TScope>;
}

/**
 * Represents either a {@link ServiceFactory} or a function that returns one.
 *
 * @public
 */
export declare type ServiceFactoryOrFunction = ServiceFactory | (() => ServiceFactory);

/**
 * TODO
 *
 * @public
 */
export declare type ServiceRef<TService, TScope extends 'root' | 'plugin' = 'root' | 'plugin'> = {
    id: string;
    /**
     * This determines the scope at which this service is available.
     *
     * Root scoped services are available to all other services but
     * may only depend on other root scoped services.
     *
     * Plugin scoped services are only available to other plugin scoped
     * services but may depend on all other services.
     */
    scope: TScope;
    /**
     * Utility for getting the type of the service, using `typeof serviceRef.T`.
     * Attempting to actually read this value will result in an exception.
     */
    T: TService;
    toString(): string;
    $$type: '@backstage/ServiceRef';
};

/** @public */
export declare interface ServiceRefConfig<TService, TScope extends 'root' | 'plugin'> {
    id: string;
    scope?: TScope;
    defaultFactory?: (service: ServiceRef<TService, TScope>) => Promise<ServiceFactoryOrFunction>;
}

/** @ignore */
declare type ServiceRefsToInstances<T extends {
    [key in string]: ServiceRef<unknown>;
}, TScope extends 'root' | 'plugin' = 'root' | 'plugin'> = {
    [key in keyof T as T[key]['scope'] extends TScope ? key : never]: T[key]['T'];
};

/**
 * An opaque type that represents the contents of a shared backend environment.
 *
 * @public
 */
export declare interface SharedBackendEnvironment {
    $$type: '@backstage/SharedBackendEnvironment';
}

/**
 * The configuration options passed to {@link createSharedEnvironment}.
 *
 * @public
 */
export declare interface SharedBackendEnvironmentConfig {
    services?: ServiceFactoryOrFunction[];
}

/**
 * Interface for creating and validating tokens.
 *
 * @public
 */
export declare interface TokenManagerService {
    /**
     * Fetches a valid token.
     *
     * @remarks
     *
     * Tokens are valid for roughly one hour; the actual deadline is set in the
     * payload `exp` claim. Never hold on to tokens for reuse; always ask for a
     * new one for each outgoing request. This ensures that you always get a
     * valid, fresh one.
     */
    getToken(): Promise<{
        token: string;
    }>;
    /**
     * Validates a given token.
     */
    authenticate(token: string): Promise<void>;
}

/**
 * A generic interface for fetching plain data from URLs.
 *
 * @public
 */
export declare interface UrlReaderService {
    /**
     * Reads a single file and return its content.
     */
    readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
    /**
     * Reads a full or partial file tree.
     */
    readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
    /**
     * Searches for a file in a tree using a glob pattern.
     */
    search(url: string, options?: SearchOptions): Promise<SearchResponse>;
}

export { }
